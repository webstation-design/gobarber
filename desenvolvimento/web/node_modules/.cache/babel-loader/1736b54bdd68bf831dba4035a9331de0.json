{"ast":null,"code":"// Should be no imports here!\nvar _a; // SOme things that should be evaluated before all else...\n\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = hasSymbol ? Symbol(\"immer-nothing\") : (_a = {}, _a[\"immer-nothing\"] = true, _a);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = hasSymbol ? Symbol(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? Symbol(\"immer-state\") : \"__$immer_state\";\nvar iteratorSymbol = hasSymbol ? Symbol.iterator : \"@@iterator\";\n/* istanbul ignore next */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n\n  return extendStatics(d, b);\n}; // Ugly hack to resolve #502 and inherit built in Map / Set\n\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = ( // @ts-ignore\n  __.prototype = b.prototype, new __());\n}\n\nvar Archtype;\n\n(function (Archtype) {\n  Archtype[Archtype[\"Object\"] = 0] = \"Object\";\n  Archtype[Archtype[\"Array\"] = 1] = \"Array\";\n  Archtype[Archtype[\"Map\"] = 2] = \"Map\";\n  Archtype[Archtype[\"Set\"] = 3] = \"Set\";\n})(Archtype || (Archtype = {}));\n\nvar ProxyType;\n\n(function (ProxyType) {\n  ProxyType[ProxyType[\"ProxyObject\"] = 0] = \"ProxyObject\";\n  ProxyType[ProxyType[\"ProxyArray\"] = 1] = \"ProxyArray\";\n  ProxyType[ProxyType[\"ES5Object\"] = 2] = \"ES5Object\";\n  ProxyType[ProxyType[\"ES5Array\"] = 3] = \"ES5Array\";\n  ProxyType[ProxyType[\"Map\"] = 4] = \"Map\";\n  ProxyType[ProxyType[\"Set\"] = 5] = \"Set\";\n})(ProxyType || (ProxyType = {}));\n/** Returns true if the given value is an Immer draft */\n\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\n\nfunction each(obj, iter) {\n  if (getArchtype(obj) === Archtype.Object) {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return desc && desc.enumerable ? true : false;\n}\n\nfunction getArchtype(thing) {\n  /* istanbul ignore next */\n  if (!thing) {\n    die();\n  }\n\n  if (thing[DRAFT_STATE]) {\n    switch (thing[DRAFT_STATE].type) {\n      case ProxyType.ES5Object:\n      case ProxyType.ProxyObject:\n        return Archtype.Object;\n\n      case ProxyType.ES5Array:\n      case ProxyType.ProxyArray:\n        return Archtype.Array;\n\n      case ProxyType.Map:\n        return Archtype.Map;\n\n      case ProxyType.Set:\n        return Archtype.Set;\n    }\n  }\n\n  return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;\n}\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  // @ts-ignore\n  return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\n}\n\nfunction set(thing, propOrOldValue, value) {\n  switch (getArchtype(thing)) {\n    case Archtype.Map:\n      thing.set(propOrOldValue, value);\n      break;\n\n    case Archtype.Set:\n      thing.delete(propOrOldValue);\n      thing.add(value);\n      break;\n\n    default:\n      thing[propOrOldValue] = value;\n  }\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) {\n    invokeGetters = false;\n  }\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction freeze(obj, deep) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  var type = getArchtype(obj);\n\n  if (type === Archtype.Set) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (type === Archtype.Map) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n/* istanbul ignore next */\n\n\nfunction die() {\n  throw new Error(\"Illegal state, please file a bug\");\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope =\n/** @class */\nfunction () {\n  function ImmerScope(parent, immer) {\n    this.drafts = [];\n    this.parent = parent;\n    this.immer = immer; // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n\n    this.canAutoFreeze = true;\n  }\n\n  ImmerScope.prototype.usePatches = function (patchListener) {\n    if (patchListener) {\n      this.patches = [];\n      this.inversePatches = [];\n      this.patchListener = patchListener;\n    }\n  };\n\n  ImmerScope.prototype.revoke = function () {\n    this.leave();\n    this.drafts.forEach(revoke); // @ts-ignore\n\n    this.drafts = null;\n  };\n\n  ImmerScope.prototype.leave = function () {\n    if (this === ImmerScope.current) {\n      ImmerScope.current = this.parent;\n    }\n  };\n\n  ImmerScope.enter = function (immer) {\n    var scope = new ImmerScope(ImmerScope.current, immer);\n    ImmerScope.current = scope;\n    return scope;\n  };\n\n  return ImmerScope;\n}();\n\nfunction revoke(draft) {\n  var state = draft[DRAFT_STATE];\n\n  if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {\n    state.revoke();\n  } else {\n    state.revoked = true;\n  }\n}\n\nfunction processResult(immer, result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  immer.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = finalize(immer, result, scope);\n\n      if (!scope.parent) {\n        maybeFreeze(immer, result);\n      }\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = finalize(immer, baseDraft, scope, []);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n}\n\nfunction finalize(immer, draft, scope, path) {\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return finalizeTree(immer, draft, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    maybeFreeze(immer, state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (immer.onDelete && state.type !== ProxyType.Set) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (immer.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            immer.onDelete(state, prop);\n          }\n        });\n      } else {\n        var base = state.base,\n            copy_1 = state.copy;\n        each(base, function (prop) {\n          if (!has(copy_1, prop)) {\n            immer.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (immer.onCopy) {\n      immer.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (immer.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n}\n\nfunction finalizeTree(immer, root, scope, rootPath) {\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  each(root, function (key, value) {\n    return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);\n  });\n  return root;\n}\n\nfunction finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {\n  if (childValue === parentValue) {\n    throw Error(\"Immer forbids circular references\");\n  } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n  var isDraftProp = !!rootState && parentValue === root;\n  var isSetMember = isSet(parentValue);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.\n    !has(rootState.assigned, prop) // Skip deep patches for assigned keys.\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n\n    childValue = finalize(immer, childValue, scope, path);\n    set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.\n\n    if (isDraft(childValue)) {\n      scope.canAutoFreeze = false;\n    }\n  } // Unchanged draft properties are ignored.\n  else if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n    // especially the passing on of root and rootState doesn't make sense...\n    else if (isDraftable(childValue)) {\n        each(childValue, function (key, grandChild) {\n          return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);\n        });\n\n        if (!scope.parent) {\n          maybeFreeze(immer, childValue);\n        }\n      }\n\n  if (isDraftProp && immer.onAssign && !isSetMember) {\n    immer.onAssign(rootState, prop, childValue);\n  }\n}\n\nfunction maybeFreeze(immer, value, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (immer.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,\n    // Track which produce call this is associated with.\n    scope: parent ? parent.scope : ImmerScope.current,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null,\n    isManual: false\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n  // and administrate revoking ourselves\n\n\n  var _a = Proxy.revocable(target, traps),\n      revoke = _a.revoke,\n      proxy = _a.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\n\nvar objectTraps = {\n  get: function (state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n      // @ts-ignore\n\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = state.scope.immer.createProxy(value, state);\n  },\n  has: function (state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function (state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function (state, prop\n  /* strictly not, but helps TS */\n  , value) {\n    if (!state.modified) {\n      var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n      if (isUnchanged) {\n        return true;\n      }\n\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    state.assigned[prop] = true; // @ts-ignore\n\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function (state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    } // @ts-ignore\n\n\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function (state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = state.type !== ProxyType.ProxyArray || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function () {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function (state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function () {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  // @ts-ignore\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n/**\r\n * Map drafts\r\n */\n// Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {\n      var copy_1 = state.copy = shallowCopy(state.base);\n      each(state.drafts, function (key, value) {\n        // @ts-ignore\n        copy_1[key] = value;\n      });\n      state.drafts = undefined;\n    }\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = shallowCopy(state.base);\n  }\n}\n\nfunction willFinalizeES5(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\n\nfunction createES5Proxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  });\n  var state = {\n    type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,\n    scope: parent ? parent.scope : ImmerScope.current,\n    modified: false,\n    finalizing: false,\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoked: false,\n    isManual: false\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  return draft;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek$1(latest(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek$1(state.base, prop) && isDraftable(value)) {\n    prepareCopy$1(state); // @ts-ignore\n\n    return state.copy[prop] = state.scope.immer.createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set$1(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek$1(latest(state), prop))) {\n      return;\n    }\n\n    markChangedES5(state);\n    prepareCopy$1(state);\n  } // @ts-ignore\n\n\n  state.copy[prop] = value;\n}\n\nfunction markChangedES5(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChangedES5(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy$1(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function () {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function (value) {\n        set$1(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      switch (state.type) {\n        case ProxyType.ES5Array:\n          if (hasArrayChanges(state)) {\n            markChangedES5(state);\n          }\n\n          break;\n\n        case ProxyType.ES5Object:\n          if (hasObjectChanges(state)) {\n            markChangedES5(state);\n          }\n\n          break;\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned,\n      type = state.type;\n\n  if (type === ProxyType.ES5Object) {\n    // Look for added keys.\n    // TODO: looks quite duplicate to hasObjectChanges,\n    // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n    // unnecessary work.\n    // also: probably we can store the information we detect here, to speed up tree finalization!\n    each(draft, function (key) {\n      if (key === DRAFT_STATE) {\n        return;\n      } // The `undefined` check is a fast path for pre-existing keys.\n\n\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChangedES5(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    each(base, function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChangedES5(state);\n      }\n    });\n  } else if (type === ProxyType.ES5Array) {\n    if (hasArrayChanges(state)) {\n      markChangedES5(state);\n      assigned.length = true;\n    }\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i = base.length; i < draft.length; i++) {\n        assigned[i] = true;\n      }\n    } // Minimum count is enough, the other parts has been processed.\n\n\n    var min = Math.min(draft.length, base.length);\n\n    for (var i = 0; i < min; i++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i] === undefined) {\n        markChangesRecursively(draft[i]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state_1 = value && value[DRAFT_STATE];\n\n        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nvar DraftMap = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Map is not polyfilled\");\n  }\n\n  __extends(DraftMap, _super); // Create class manually, cause #502\n\n\n  function DraftMap(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Map,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      assigned: undefined,\n      base: target,\n      draft: this,\n      isManual: false,\n      revoked: false\n    };\n    return this;\n  }\n\n  var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty\n\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (key) {\n    return latest(this[DRAFT_STATE]).has(key);\n  };\n\n  p.set = function (key, value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (latest(state).get(key) !== value) {\n      prepareCopy$2(state);\n      state.scope.immer.markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n      state.assigned.set(key, true);\n    }\n\n    return this;\n  };\n\n  p.delete = function (key) {\n    if (!this.has(key)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return true;\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned = new Map();\n    return state.copy.clear();\n  };\n\n  p.forEach = function (cb, thisArg) {\n    var _this = this;\n\n    var state = this[DRAFT_STATE];\n    latest(state).forEach(function (_value, key, _map) {\n      cb.call(thisArg, _this.get(key), key, _this);\n    });\n  };\n\n  p.get = function (key) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    var value = latest(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value; // either already drafted or reassigned\n    } // despite what it looks, this creates a draft only once, see above condition\n\n\n    var draft = state.scope.immer.createProxy(value, state);\n    prepareCopy$2(state);\n    state.copy.set(key, draft);\n    return draft;\n  };\n\n  p.keys = function () {\n    return latest(this[DRAFT_STATE]).keys();\n  };\n\n  p.values = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.values();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) {\n        return r;\n      }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: value\n      };\n    }, _a;\n  };\n\n  p.entries = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.entries();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) {\n        return r;\n      }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: [r.value, value]\n      };\n    }, _a;\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.entries();\n  };\n\n  return DraftMap;\n}(Map);\n\nfunction proxyMap(target, parent) {\n  // @ts-ignore\n  return new DraftMap(target, parent);\n}\n\nfunction prepareCopy$2(state) {\n  if (!state.copy) {\n    state.assigned = new Map();\n    state.copy = new Map(state.base);\n  }\n}\n\nvar DraftSet = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Set is not polyfilled\");\n  }\n\n  __extends(DraftSet, _super); // Create class manually, cause #502\n\n\n  function DraftSet(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Set,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      base: target,\n      draft: this,\n      drafts: new Map(),\n      revoked: false,\n      isManual: false\n    };\n    return this;\n  }\n\n  var p = DraftSet.prototype;\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n\n    if (!state.copy) {\n      return state.base.has(value);\n    }\n\n    if (state.copy.has(value)) {\n      return true;\n    }\n\n    if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) {\n      return true;\n    }\n\n    return false;\n  };\n\n  p.add = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (state.copy) {\n      state.copy.add(value);\n    } else if (!state.base.has(value)) {\n      prepareCopy$3(state);\n      state.scope.immer.markChanged(state);\n      state.copy.add(value);\n    }\n\n    return this;\n  };\n\n  p.delete = function (value) {\n    if (!this.has(value)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :\n    /* istanbul ignore next */\n    false);\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.clear();\n  };\n\n  p.values = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.values();\n  };\n\n  p.entries = function entries() {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.entries();\n  };\n\n  p.keys = function () {\n    return this.values();\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.values();\n  };\n\n  p.forEach = function forEach(cb, thisArg) {\n    var iterator = this.values();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, this);\n      result = iterator.next();\n    }\n  };\n\n  return DraftSet;\n}(Set);\n\nfunction proxySet(target, parent) {\n  // @ts-ignore\n  return new DraftSet(target, parent);\n}\n\nfunction prepareCopy$3(state) {\n  if (!state.copy) {\n    // create drafts for all entries to preserve insertion order\n    state.copy = new Set();\n    state.base.forEach(function (value) {\n      if (isDraftable(value)) {\n        var draft = state.scope.immer.createProxy(value, state);\n        state.drafts.set(value, draft);\n        state.copy.add(draft);\n      } else {\n        state.copy.add(value);\n      }\n    });\n  }\n}\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  switch (state.type) {\n    case ProxyType.ProxyObject:\n    case ProxyType.ES5Object:\n    case ProxyType.Map:\n      return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n    case ProxyType.ES5Array:\n    case ProxyType.ProxyArray:\n      return generateArrayPatches(state, basePath, patches, inversePatches);\n\n    case ProxyType.Set:\n      return generateSetPatches(state, basePath, patches, inversePatches);\n  }\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var _a, _b;\n\n  var base = state.base,\n      assigned = state.assigned,\n      copy = state.copy;\n  /* istanbul ignore next */\n\n  if (!copy) {\n    die();\n  } // Reduce complexity by ensuring `base` is never longer.\n\n\n  if (copy.length < base.length) {\n    _a = [copy, base], base = _a[0], copy = _a[1];\n    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i = end + delta - 1; i >= end; --i) {\n    var path = basePath.concat([i]);\n    patches[replaceCount + i - end] = {\n      op: \"add\",\n      path: path,\n      value: copy[i]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  var i = 0;\n  base.forEach(function (value) {\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n  i = 0;\n  copy.forEach(function (value) {\n    if (!base.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  patches.forEach(function (patch) {\n    var path = patch.path,\n        op = patch.op;\n    /* istanbul ignore next */\n\n    if (!path.length) {\n      die();\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var type = getArchtype(base);\n    var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        switch (type) {\n          case Archtype.Map:\n            return base.set(key, value);\n\n          /* istanbul ignore next */\n\n          case Archtype.Set:\n            throw new Error('Sets cannot have \"replace\" patches.');\n\n          default:\n            // if value is an object, then it's assigned by reference\n            // in the following add or remove ops, the value field inside the patch will also be modifyed\n            // so we use value from the cloned patch\n            // @ts-ignore\n            return base[key] = value;\n        }\n\n      case \"add\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 0, value);\n\n          case Archtype.Map:\n            return base.set(key, value);\n\n          case Archtype.Set:\n            return base.add(value);\n\n          default:\n            return base[key] = value;\n        }\n\n      case \"remove\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 1);\n\n          case Archtype.Map:\n            return base.delete(key);\n\n          case Archtype.Set:\n            return base.delete(patch.value);\n\n          default:\n            return delete base[key];\n        }\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  });\n  return draft;\n}\n\nfunction deepClonePatchValue(obj) {\n  if (!obj || typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(deepClonePatchValue);\n  }\n\n  if (isMap(obj)) {\n    return new Map(Array.from(obj.entries()).map(function (_a) {\n      var k = _a[0],\n          v = _a[1];\n      return [k, deepClonePatchValue(v)];\n    }));\n  }\n\n  if (isSet(obj)) {\n    return new Set(Array.from(obj).map(deepClonePatchValue));\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = deepClonePatchValue(obj[key]);\n  }\n\n  return cloned;\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n/* istanbul ignore next */\n\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" :\n  /* istanbul ignore next */\n  verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer =\n/** @class */\nfunction () {\n  function Immer(config) {\n    var _this = this;\n\n    this.useProxies = false;\n    this.autoFreeze = false;\n    each(configDefaults, function (key, value) {\n      var _a, _b; // @ts-ignore\n\n\n      _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);\n    });\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n    this.produceWithPatches = this.produceWithPatches.bind(this);\n  }\n  /**\r\n   * The `produce` function takes a value and a \"recipe function\" (whose\r\n   * return value often depends on the base state). The recipe function is\r\n   * free to mutate its first argument however it wants. All mutations are\r\n   * only ever applied to a __copy__ of the base state.\r\n   *\r\n   * Pass only a function to create a \"curried producer\" which relieves you\r\n   * from passing the recipe function every time.\r\n   *\r\n   * Only plain objects and arrays are made mutable. All other objects are\r\n   * considered uncopyable.\r\n   *\r\n   * Note: This function is __bound__ to its `Immer` instance.\r\n   *\r\n   * @param {any} base - the initial state\r\n   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n   * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n   * @returns {any} a new state, or the initial state if nothing was modified\r\n   */\n\n\n  Immer.prototype.produce = function (base, recipe, patchListener) {\n    var _this = this; // curried invocation\n\n\n    if (typeof base === \"function\" && typeof recipe !== \"function\") {\n      var defaultBase_1 = recipe;\n      recipe = base;\n      var self_1 = this;\n      return function curriedProduce(base) {\n        var arguments$1 = arguments;\n\n        var _this = this;\n\n        if (base === void 0) {\n          base = defaultBase_1;\n        }\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return self_1.produce(base, function (draft) {\n          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));\n        }); // prettier-ignore\n      };\n    } // prettier-ignore\n\n\n    {\n      if (typeof recipe !== \"function\") {\n        throw new Error(\"The first or second argument to `produce` must be a function\");\n      }\n\n      if (patchListener !== undefined && typeof patchListener !== \"function\") {\n        throw new Error(\"The third argument to `produce` must be a function or undefined\");\n      }\n    }\n    var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n    if (isDraftable(base)) {\n      var scope_1 = ImmerScope.enter(this);\n      var proxy = this.createProxy(base, undefined);\n      var hasError = true;\n\n      try {\n        result = recipe(proxy);\n        hasError = false;\n      } finally {\n        // finally instead of catch + rethrow better preserves original stack\n        if (hasError) {\n          scope_1.revoke();\n        } else {\n          scope_1.leave();\n        }\n      }\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (result) {\n          scope_1.usePatches(patchListener);\n          return processResult(_this, result, scope_1);\n        }, function (error) {\n          scope_1.revoke();\n          throw error;\n        });\n      }\n\n      scope_1.usePatches(patchListener);\n      return processResult(this, result, scope_1);\n    } else {\n      result = recipe(base);\n\n      if (result === NOTHING) {\n        return undefined;\n      }\n\n      if (result === undefined) {\n        result = base;\n      }\n\n      maybeFreeze(this, result, true);\n      return result;\n    }\n  };\n\n  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {\n    var _this = this;\n\n    if (typeof arg1 === \"function\") {\n      return function (state) {\n        var arguments$1 = arguments;\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return _this.produceWithPatches(state, function (draft) {\n          return arg1.apply(void 0, __spreadArrays([draft], args));\n        });\n      };\n    } // non-curried form\n\n    /* istanbul ignore next */\n\n\n    if (arg3) {\n      die();\n    }\n\n    var patches, inversePatches;\n    var nextState = this.produce(arg1, arg2, function (p, ip) {\n      patches = p;\n      inversePatches = ip;\n    });\n    return [nextState, patches, inversePatches];\n  };\n\n  Immer.prototype.createDraft = function (base) {\n    if (!isDraftable(base)) {\n      throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n    }\n\n    var scope = ImmerScope.enter(this);\n    var proxy = this.createProxy(base, undefined);\n    proxy[DRAFT_STATE].isManual = true;\n    scope.leave();\n    return proxy;\n  };\n\n  Immer.prototype.finishDraft = function (draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    if (!state || !state.isManual) {\n      throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n    }\n\n    if (state.finalized) {\n      throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n    }\n\n    var scope = state.scope;\n    scope.usePatches(patchListener);\n    return processResult(this, undefined, scope);\n  };\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is disabled in production.\r\n   */\n\n\n  Immer.prototype.setAutoFreeze = function (value) {\n    this.autoFreeze = value;\n  };\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n\n\n  Immer.prototype.setUseProxies = function (value) {\n    this.useProxies = value;\n  };\n\n  Immer.prototype.applyPatches = function (base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatches(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatches(draft, patches.slice(i + 1));\n    });\n  };\n\n  Immer.prototype.createProxy = function (value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);\n    var scope = parent ? parent.scope : ImmerScope.current;\n    scope.drafts.push(draft);\n    return draft;\n  };\n\n  Immer.prototype.willFinalize = function (scope, thing, isReplaced) {\n    if (!this.useProxies) {\n      willFinalizeES5(scope, thing, isReplaced);\n    }\n  };\n\n  Immer.prototype.markChanged = function (state) {\n    if (this.useProxies) {\n      markChanged(state);\n    } else {\n      markChangedES5(state);\n    }\n  };\n\n  return Immer;\n}();\n\nvar immer = new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * By default, auto-freezing is disabled in production.\r\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\n\nfunction castDraft(value) {\n  return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\n\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, castDraft, castImmutable, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":null,"metadata":{},"sourceType":"module"}